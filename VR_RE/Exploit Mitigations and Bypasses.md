# Developer
Measures taken that are not exploit specific
- Careful placement of buffers relative to other data
- Copying data and comparing data against copy or using the copy outright
- Data validation

# Stack Canary
A secret value placed on the stack prior to return address by prologue, and compared against in epilogue. Canary types:
- `Null` - All 0
- `Terminator` Null, CR, LF,  etc to stop most `strcpy/puts/gets` functions
- `Random` Canary generated at program start
- `Random XOR` Random value at program start XOR with control data of function

## GCC
`-fstack-protector` protects
- `alloca` calls
- buffers > 8 bytes
`-fstack-protector-all` protects
- every function
- spends a lot of time checking guard variables (performance hit)
`-fstack-protector-strong` protectcs
- same as `fstack-protector`
- local array defs
- references to local stack frame


## Defeats
- Brute force (fork doesn't change value)
- Info leak
- Replace comparison canary
- smash SEH and cause exception (Windows)

# DEP/NX 
Memory pages are marked non executable. Any attempted to point IP at code in these pages will trigger a fault. 
## Defeats
change memory permissions (`mprotect()`)
ROP/JOP

# W^X
Concept that memory pages can be marked `X` or `W` but not both
## Defeats
Call library to change permissions on page


# Position Independent X

## Position Independent Code
Primarily shared libraries (and shellcode). Makes use of relative offsets and avoids hard coding addresses

## Position Independent Executable
Technically refers the Linux/ELF way of making the **binary** relocatable in memory just like the shared libraries. Still makes uses of relative addresses and avoiding hard coded addreses

Binaries uses relative addresses to allow it to be loaded into a different memory address each time. 

Linux `gcc -fPIE` or  Windows`/DYNAMICBASE` [MSDN](https://learn.microsoft.com/en-us/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=msvc-170)
## Defeats
Memory leak of library pointer to global or function

# ASLR 
0,1,2 => `/proc/sys/kernel/randomize_va_space`
Makes use of binaries compiled as position independent executables
- Linux `gcc -fPIE` 
- Windows`/DYNAMICBASE` [MSDN](https://learn.microsoft.com/en-us/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=msvc-170)

OS scrambles address space of a program
- Linux each run of exe/so
- Windows: First load is random, reboot re-rerandomizes
	- If DLL is loaded at offset in an exe, it's there for all exes using it

## Defeats
- Same as Position Independent 
- Jumping back to main/a function to keep process alive and not daemonized
- Spraying if 32-bit is a decent choice
- Other memory grooming techniques

`RELRO` ELF internal data sections (.got, .dtors, etc.) are before the data sections (.data and .bss) to prevent overflowing INTO them
- `Partial RELRO` non-PLT GOT is RO, GOT is RW
- `Full RELRO` Above + got is remapped as RO

# SMEP - Supervisor Mode Execution Prevention
Introduced in Intel Ivy Bridge processors in 2011

Prevents **EXECUTION** of user mode addresses while in kernel mode. An arbitrary address could be used to execute code to gain privesc. 
- BOF, UAF, TOCTOU significantly mitigated

# SMAP - Supervisor Mode Access Prevention
Introduced in Intel Broadwell processors (2014)
Supported in Linux since 3.7
Prevents **ACCESS** of user mode addresses while in kernel mode
- No more userspace ROP chain
- disabled selectively when needed for syscalls that read parameters  

# CFG/EFG
- Windows specific
# Bypasses / Techniques
`Shellcode` - Position independent code that is injected and executed. 

`ret2ret` - if a value at a fixed offset on the stack points at or near your shellcode, overwrite stack with `ret` until then

`ret2eax` Return values are in EAX/RAX. `strcpy` et al returns a user-controlled buffer, so following it with `call [eax]`or `jmp [eax]` can start shellcode execution

`ret2libc` - Execution is passed to `system()` to run a command with `/bin/sh whatever`

`stack pivot` - instruction that changes stack pointer to attacker controlled memory. Fake stack may be used for ROP or further exploitation. `pop rsp` or `xchg`
 - `leave, ret` where leave maps to `mov rsp, rbp; pop rbp` can called back to back to move value from `rbp` into `rip` via `rsp`

`ROP/JOP` - A chain of pointers to gadgets. Each gadget performs some desired action and then ends with a branch instruction (usually `ret`). Interspersed with these pointers will be any data necessary for each gadget to make use of. Can be used to call `system()` or make shellcode executable and jump to it

`ret2csu` - `__libc_csu_init` Has 2 gadgets that can be reused over and over to call other gadgets, typically to populate registers for function calls
- https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf

`memory leak` - libc function, global address typically used to defeat ASLR

`ret2plt` - If no info leak, call `puts@plt` with itself as the pointer and it will print until a null byte. Take the first pointer-width bytes and do offset math, then call the function accepting user input again and exploit normally.

`GOT Overwrite` - Address table for all functions. Just overwriting the pointer and call the function. 
- Function is initially populated with `func@PLT` initially. When called for the first time, the PLT will check `GOT` entry. If it's been resolved, it will jump to that pointer. Otherwise the stub will determine the address, populate the GOT entry for next time, and jump there.
- Calling `func@plt` is same as calling func directly
- Overwrite AFTER first call
- https://0x434b.dev/an-introduction-to-data-stack-canaries-in-linux/

`__malloc_hook` The function pointer called when `malloc()` is invoked. It can be overwritten (e.g., `execve("/bin/sh"` from libc))
- Allocating too many bytes on the stack will trigger a malloc. ``printf("%10000$c")

`ret2dlresolve` - faking Elf structures to resolve a function not in plt 
- https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve

